---
description: These rules describe the project module development patterns. 
globs: 
alwaysApply: false
---
# Module Development Patterns & Guidelines

## Project Structure & Module Organization

### Module Architecture

- Organize code by feature/domain modules under `src/modules/` and `src/app/[locale]`
- Each module should have clear separation: `ui/components/`, `ui/views/`, `lib/`, `types/`
- Every `page.tsx` inside the `src/app/[locale]/{domain}/*` must contain only `views` from `src/modules/{domain}/ui/views`
- Every `page.tsx` inside the `src/app/[locale]/(private)/{domain}/*` must contain only `views` from `src/modules/{domain}/ui/views`
- **IMPORTANT:** Pages in `src/app/[locale]/(private)/**` must implement per-page authentication using better-auth-ui components
- Reference example: [page.tsx](mdc:src/app/[locale]/(private)/account/security/page.tsx) [security-view.tsx](mdc:src/modules/auth/ui/views/security-view.tsx) [new-organization-form.tsx](mdc:src/modules/auth/ui/components/new-organization-form.tsx)

### Component Structure

```bash
src/modules/{domain}/
â”œâ”€â”€ ui/
â”‚   â”œâ”€â”€ components/     # Reusable components
â”‚   â””â”€â”€ views/         # Page-level components
â”œâ”€â”€ lib/               # Business logic, utils
â”œâ”€â”€ types/            # TypeScript type definitions
â””â”€â”€ hooks/            # Custom React hooks

src/app/[locale]/
â”œâ”€â”€ (private)/         # ðŸ”’ Protected routes - each page handles own authentication
â”‚   â”œâ”€â”€ {domain}/      # Feature-specific protected pages
â”‚   â”‚   â””â”€â”€ page.tsx   # Must use views from src/modules/{domain}/ui/views + auth components
â”‚   â””â”€â”€ layout.tsx     # Layout wrapper (no authentication logic)
â””â”€â”€ (public)/          # Public routes
    â””â”€â”€ {domain}/      # Feature-specific public pages
        â””â”€â”€ page.tsx   # Can use views from src/modules/{domain}/ui/views
```

## Authentication Requirements (Better Auth)

### Per-Page Authentication Pattern

**The project uses a per-page authentication approach using @daveyplate/better-auth-ui:**

- Each protected page implements its own authentication check
- Pages use `RedirectToSignIn` and `SignedIn` components for consistent auth behavior
- The `RedirectToSignIn` component automatically redirects unauthenticated users
- The `SignedIn` component renders content only for authenticated users

### Better Auth UI Components

```typescript
import { RedirectToSignIn, SignedIn } from "@daveyplate/better-auth-ui"

export default function ProtectedPage() {
  return (
    <>
      <RedirectToSignIn />
      <SignedIn>
        {/* Your protected content here */}
        <YourDomainView />
      </SignedIn>
    </>
  )
}
```

### How the Components Work

- **`<RedirectToSignIn />`**: Automatically redirects unauthenticated users to the sign-in page
- **`<SignedIn>`**: Renders its children only when the user is authenticated
- These components handle all authentication logic internally
- No manual session checks or redirect logic needed

### Private Page Pattern (Per-Page Authentication)

```typescript
// âœ… DO: Each private page handles its own authentication
import { RedirectToSignIn, SignedIn } from "@daveyplate/better-auth-ui"

export default function PrivatePage() {
  return (
    <>
      <RedirectToSignIn />
      <SignedIn>
        <YourDomainView />
      </SignedIn>
    </>
  )
}
```

### Authentication Best Practices

- **ALWAYS** add `<RedirectToSignIn />` and `<SignedIn>` components to protected pages and components
- **ALWAYS** wrap your protected content inside the `<SignedIn>` component
- **NEVER** implement manual session checks when using better-auth-ui components
- **CONSISTENT** pattern: Use the same authentication components across all protected pages
- **ROLE-BASED** access can be implemented inside the `<SignedIn>` component if needed

## Form Development Standards

### 1. Validation with Zod + Translations

- **ALWAYS** use Zod for form validation schemas
- **ALWAYS** integrate translations directly into schema for consistent error messages
- Create schema factory functions that accept translation function

```typescript
const createSignupSchema = (t: (key: string) => string) => {
  return z.object({
    email: z.string()
      .min(1, { message: t("emailRequired") })
      .email({ message: t("emailInvalid") }),
    password: z.string()
      .min(8, { message: t("passwordTooShort") })
  }).refine(/* custom validation */, {
    message: t("customErrorMessage"),
    path: ["fieldName"]
  });
};
```

### 2. React Hook Form Integration

- **ALWAYS** use React Hook Form with `zodResolver`
- Use `useForm<SchemaType>()` with proper TypeScript inference
- Create form instance and pass to shadcn Form provider

```typescript
const form = useForm<SignupFormData>({
  resolver: zodResolver(signupSchema),
  defaultValues: { /* ... */ }
});
```

### 3. shadcn/ui Form Components Suite

- **ALWAYS** use the complete shadcn Form components suite:
  - `<Form {...form}>` - Provider wrapper
  - `<FormField>` - Individual field wrapper with render props
  - `<FormItem>` - Field container with consistent spacing
  - `<FormLabel>` - Accessible labels
  - `<FormControl>` - Input wrapper with aria attributes
  - `<FormMessage>` - Automatic error display
  - `<FormDescription>` - Help text and hints

```typescript
<FormField
  control={form.control}
  name="fieldName"
  render={({ field }) => (
    <FormItem>
      <FormLabel>{t("label")}</FormLabel>
      <FormControl>
        <Input {...field} />
      </FormControl>
      <FormDescription>{t("helpText")}</FormDescription>
      <FormMessage />
    </FormItem>
  )}
/>
```

## Translation Patterns (next-intl)

### Translation Integration

- Use `useTranslations("Domain")` hook for component translations
- Create translation schema factory functions for consistent error messages
- Use semantic translation keys: `"emailRequired"`, `"passwordTooShort"`

### Translation Best Practices

- Group translations by domain/module
- Use descriptive keys that indicate the UI element and context
- For optional fields: `{t("fieldName")} <span className="text-muted-foreground">({t("optional")})</span>`

## Component Development Guidelines

### TypeScript Patterns

- **ALWAYS** use proper TypeScript interfaces for props
- Use Zod schema type inference: `type FormData = z.infer<typeof schema>`
- Maintain strict typing throughout component hierarchy

### UI/UX Patterns

- Use consistent spacing: `className="space-y-6"` for forms
- Implement loading states with proper disabled attributes
- Use shadcn design tokens: `text-muted-foreground`, `text-destructive`
- Implement accessibility: proper ARIA attributes, screen reader support

### State Management

- Avoid manual state for form fields - let React Hook Form handle it
- Use controlled components sparingly (e.g., password visibility toggles)
- Leverage form's built-in validation and error states

## Authentication Module Patterns

### Form Security

- Implement password visibility toggles with eye icons
- Use proper input types: `type="email"`, `type="password"`
- Implement client-side validation before submission
- Handle async submission with proper error handling

### Component Props Interface

```typescript
interface AuthFormProps {
  onSubmit: (data: FormData) => Promise<void>;
  isLoading: boolean;
}
```

## Error Handling & Validation

### Validation Strategy

- Schema-first validation with Zod
- Real-time validation feedback
- Localized error messages
- Field-level and form-level validation

### Error Display

- Use `<FormMessage />` for automatic error display
- Errors appear below their respective fields
- Use semantic error paths for custom validations (e.g., password confirmation)

## Code Quality Standards

### Comments & Documentation

- **ALWAYS** include JSDoc comments for components explaining their purpose
- Document validation rules and their reasoning
- Include usage examples in complex components
- Explain business logic and custom validation rules

### Clean Code Principles

- Keep components focused and single-purpose
- Extract reusable patterns into hooks or utilities
- Use descriptive variable and function names
- Maintain consistent code formatting and structure

## Performance Considerations

### React Hook Form Benefits

- Uncontrolled components reduce re-renders
- Built-in validation optimization
- Efficient form state management
- Minimal bundle size impact

### Component Optimization

- Avoid inline object/function creation in render

This rule set ensures consistent, maintainable, and user-friendly form development across all modules in the application.
