---
description: This rule defines patterns for implementing role-based access control using the Better Auth RBAC system integrated in this project.
globs: 
alwaysApply: false
---
# RBAC System Guidelines

This rule defines patterns for implementing role-based access control using the Better Auth RBAC system integrated in this project.

## 🏗️ **RBAC Architecture Overview**

The RBAC system is split into **three distinct modules** to prevent server/client import conflicts:

### **File Structure**
```
src/lib/rbac/
├── server.ts     # 🔒 Server-only utilities (uses next/headers)
├── client.ts     # 🌐 Client-only utilities (Better Auth client)
├── shared.ts     # 🔄 Shared utilities (types, constants, role hierarchy)
└── index.ts      # 📋 Main exports (re-exports shared + client only)
```

## 🔧 **Import Patterns - CRITICAL RULES**

### **✅ DO: Use Correct Imports**

```typescript
// 🔒 SERVER COMPONENTS - Import server utilities directly
import { ServerPermissions } from "@/lib/rbac/server";

// 🌐 CLIENT COMPONENTS - Use main index or client directly  
import { ClientPermissions, CommonPermissions, RoleChecks } from "@/lib/rbac";
// OR
import { ClientPermissions } from "@/lib/rbac/client";
import { CommonPermissions } from "@/lib/rbac/shared";

// 🔄 SHARED UTILITIES - Available everywhere
import { type ValidRole, type Permission, hasRoleLevel } from "@/lib/rbac/shared";
```

### **❌ DON'T: Import Server Utils in Client Components**

```typescript
// ❌ WRONG - Will cause "next/headers" error in client components
import { ServerPermissions } from "@/lib/rbac/server";

// ❌ WRONG - Main index doesn't re-export server utilities
import { ServerPermissions } from "@/lib/rbac";
```

## 🎯 **Permission Checking Patterns**

### **Server-Side Permission Checking**

```typescript
// In Server Components or API routes
import { ServerPermissions } from "@/lib/rbac/server";

export default async function ProtectedPage() {
  // Check permissions with automatic redirect
  await ServerPermissions.requirePermissions(
    { project: ["create", "update"] },
    "en", // locale
    "/dashboard" // fallback URL
  );

  // Or check without redirect
  const hasPermission = await ServerPermissions.hasPermission({
    project: ["read"]
  });

  if (!hasPermission) {
    return <div>Access denied</div>;
  }

  return <div>Protected content</div>;
}
```

### **Client-Side Permission Checking**

```typescript
// In Client Components
"use client";
import { usePermissions, useAuth } from "@/hooks/use-permissions";
import { CommonPermissions } from "@/lib/rbac";

export function ClientComponent() {
  const { hasPermission, isLoading } = usePermissions(CommonPermissions.PROJECT_MANAGER);
  const { isAdmin, isOwner } = useAuth();

  if (isLoading) return <div>Loading...</div>;
  
  return (
    <div>
      {hasPermission && <button>Create Project</button>}
      {isAdmin && <button>Admin Panel</button>}
    </div>
  );
}
```

## 🛡️ **Guard Component Patterns**

### **Permission-Based Guards**

```typescript
import { PermissionGuard, CommonPermissions } from "@/lib/rbac";

// Flexible permission checking
<PermissionGuard
  permissions={CommonPermissions.ADMIN_ACCESS}
  fallback={<div>Access denied</div>}
  loading={<div>Checking permissions...</div>}
>
  <AdminContent />
</PermissionGuard>

// Multiple role support (OR logic)
<PermissionGuard
  roles={["admin", "finance"]}
  requireAll={false} // At least one role required
  fallback={<div>Need admin or finance role</div>}
>
  <SpecialContent />
</PermissionGuard>
```

### **Role-Based Guards**

```typescript
import { RoleGuard, MinimumRoleGuard, AdminOnly, OwnerOnly } from "@/lib/rbac";

// Simple role checking
<RoleGuard role="admin" fallback={<div>Admin only</div>}>
  <AdminPanel />
</RoleGuard>

// Hierarchical role checking  
<MinimumRoleGuard minimumRole="projectManager" fallback={<div>PM+ required</div>}>
  <ProjectTools />
</MinimumRoleGuard>

// Convenience components
<AdminOnly fallback={<div>Admin required</div>}>
  <AdminSettings />
</AdminOnly>

<OwnerOnly>
  <DeleteOrganization />
</OwnerOnly>
```

## 🪝 **React Hooks Patterns**

### **Authentication & Role Hooks**

```typescript
import { useAuth, usePermissions, useRole, useCurrentRole } from "@/hooks/use-permissions";

export function Component() {
  // Combined auth state
  const { user, role, isAuthenticated, isAdmin, isOwner, isLoading } = useAuth();
  
  // Specific permission checking
  const { hasPermission, isLoading: permLoading } = usePermissions({
    project: ["create", "update"]
  });
  
  // Role checking
  const { hasRole: isFinance, isLoading: roleLoading } = useRole("finance");
  
  // Get current role
  const { role: currentRole } = useCurrentRole();
  
  return (
    <div>
      {isAuthenticated && <div>Welcome {user?.email}</div>}
      {isAdmin && <button>Admin Actions</button>}
      {hasPermission && <button>Create Project</button>}
    </div>
  );
}
```

## 🎭 **Role System & Hierarchy**

### **Available Roles**

```typescript
type ValidRole = "member" | "admin" | "owner" | "projectManager" | "finance";
```

### **Role Hierarchy (Highest to Lowest)**

```typescript
const RoleHierarchy = {
  owner: 100,        // 👑 Full organization access
  admin: 80,         // ⭐ User & system management  
  projectManager: 60, // 📁 Project & team management
  finance: 40,       // 💰 Financial data access
  member: 20,        // 👤 Basic access
} as const;
```

### **Role Checking Utilities**

```typescript
import { RoleChecks, hasRoleLevel } from "@/lib/rbac/shared";

// Quick role checks
const isUserAdmin = RoleChecks.isAdmin(userRole);
const canManageUsers = RoleChecks.canManageUsers(userRole);
const canAccessFinance = RoleChecks.canAccessFinance(userRole);

// Hierarchical checking
const hasMinimumRole = hasRoleLevel(userRole, "projectManager"); // true if PM or higher
```

## 📋 **Common Permission Sets**

```typescript
import { CommonPermissions } from "@/lib/rbac/shared";

// Pre-defined permission sets
CommonPermissions.ADMIN_ACCESS      // Full admin permissions
CommonPermissions.PROJECT_MANAGER   // Project management permissions  
CommonPermissions.FINANCE_ACCESS    // Finance-specific permissions
CommonPermissions.MEMBER_ACCESS     // Basic member permissions
```

## 🏛️ **Layout-Based Authentication Pattern**

**✅ DO: Use Layout Authentication (Following Better Auth Best Practices)**

```typescript
// src/app/[locale]/(private)/layout.tsx - Handles ALL private route authentication
export default async function PrivateLayout({ children }: { children: React.ReactNode }) {
  const session = await auth.api.getSession({ headers: await headers() });
  
  if (!session?.user) {
    redirect(`/${locale}/auth/sign-in`);
  }
  
  return <>{children}</>;
}

// src/app/[locale]/(private)/dashboard/page.tsx - No auth check needed!
export default async function DashboardPage() {
  // User is guaranteed to be authenticated here
  return <DashboardView />;
}
```

**❌ DON'T: Add Auth Checks to Individual Private Pages**

```typescript
// ❌ WRONG - Layout already handles this
export default async function PrivatePage() {
  const session = await auth.api.getSession({ headers: await headers() });
  if (!session) redirect('/sign-in'); // Redundant!
  
  return <div>Content</div>;
}
```

## 🔐 **Security Best Practices**

### **Server-Side Validation**

```typescript
// Always validate permissions server-side for sensitive operations
import { ServerPermissions } from "@/lib/rbac/server";

export async function POST(request: Request) {
  // Validate permissions before processing
  const hasPermission = await ServerPermissions.hasPermission({
    project: ["create"]
  });
  
  if (!hasPermission) {
    return new Response("Forbidden", { status: 403 });
  }
  
  // Process request...
}
```

### **Client-Side UI Enhancement**

```typescript
// Use client-side guards for UX, not security
<PermissionGuard permissions={{ project: ["delete"] }}>
  <DeleteButton onDelete={handleDelete} />
</PermissionGuard>
// Note: Always validate permissions server-side in handleDelete API
```

## 🧪 **Testing Patterns**

### **Component Testing**

```typescript
// Mock auth state for testing
import { useAuth } from "@/hooks/use-permissions";

jest.mock("@/hooks/use-permissions", () => ({
  useAuth: jest.fn(() => ({
    isAuthenticated: true,
    isAdmin: true,
    role: "admin",
    user: { email: "admin@test.com" }
  }))
}));
```

## 🚨 **Common Pitfalls to Avoid**

1. **❌ Server imports in client components** - Will cause next/headers error
2. **❌ Client-only security** - Always validate server-side
3. **❌ Individual page auth checks** - Use layout authentication
4. **❌ Hardcoded role checks** - Use role hierarchy utilities
5. **❌ Missing loading states** - Always handle isLoading from hooks

## 📚 **Example Implementation**

Reference the working demo at [rbac-demo-view.tsx](mdc:src/modules/rbac/ui/views/rbac-demo-view.tsx) for comprehensive examples of all patterns in action.

## 🔗 **Related Files**

- Server utilities: [rbac/server.ts](mdc:src/lib/rbac/server.ts)
- Client utilities: [rbac/client.ts](mdc:src/lib/rbac/client.ts)
- Shared utilities: [rbac/shared.ts](mdc:src/lib/rbac/shared.ts)
- React hooks: [use-permissions.ts](mdc:src/hooks/use-permissions.ts)
- Guard components: [permission-guard.tsx](mdc:src/components/rbac/permission-guard.tsx)
- Better Auth config: [auth.ts](mdc:src/lib/auth.ts)
- Permissions setup: [permissions.ts](mdc:src/lib/permissions.ts)
